import { NextResponse } from 'next/server'
import { anthropic, AI_MODELS, TOKEN_LIMITS } from "@/lib/ai-clients";
import {
  handleAPIError,
  handleValidationError,
  handleUnauthorizedError,
} from "@/lib/api-error-handler";
import { safeParseAIResponse } from "@/lib/parse-ai-json";
import { getAuthenticatedConvexClient } from "@/lib/convex-client";
import { api } from '@/convex/_generated/api'
import { getDefaultTechStack, generateMockResearchResults } from '@/lib/techStack/defaults'
import { TECH_STACK_SUGGESTION_PROMPT } from '@/lib/prompts/techStack'
import type { Id } from "@/convex/_generated/dataModel";
import { withAuth } from "@/lib/middleware/withAuth";
import type { ExtractedContext, Question, SimpleTechStack, ValidationResult } from "@/types";

const DEFAULT_STACK: SimpleTechStack = {
  frontend: "Next.js",
  backend: "Node.js with Express",
  database: "PostgreSQL",
  auth: "Clerk",
  hosting: "Vercel",
};

export const POST = withAuth(async (request, { userId, token }) => {
  try {
    const { conversationId, useAI = false } = await request.json()

    if (!conversationId) {
      return handleValidationError("Conversation ID required");
    }

    // Get authenticated Convex client
    const convexClient = getAuthenticatedConvexClient(token);

    // Fetch conversation data
    const conversation = await convexClient.query(api.conversations.get, {
      conversationId: conversationId as Id<"conversations">,
    })

    if (!conversation) {
      return handleAPIError(
        new Error("Conversation not found"),
        "find conversation",
        404
      );
    }

    // Verify ownership
    if (conversation.userId !== userId) {
      return handleUnauthorizedError();
    }

    const extractedContext = conversation.extractedContext
    const clarifyingQuestions = conversation.clarifyingQuestions

    // Convert questions to answers Record for tech stack functions
    const userAnswers: Record<string, string> | null = clarifyingQuestions
      ? clarifyingQuestions.reduce((acc: Record<string, string>, q: { id: string; answer?: string }) => {
          if (q.answer) {
            acc[q.id] = q.answer
          }
          return acc
        }, {})
      : null

    let techStack

    if (useAI && extractedContext) {
      // Use Claude for smarter suggestions
      techStack = await getAISuggestedStack(extractedContext, userAnswers)
    } else {
      // Use rule-based defaults
      techStack = getDefaultTechStack(extractedContext, userAnswers)
    }

    // Validate the stack before saving
    const validation = validateDefaultStack(techStack)

    // If there are errors, fix them before saving
    if (validation.errors.length > 0) {
      techStack = await fixStackErrors(techStack, validation.errors)
    }

    // Ensure all required fields are present for Convex mutation
    const completeStack: SimpleTechStack = {
      ...DEFAULT_STACK,
      ...techStack,
    }

    // Generate mock research results (using completeStack with all required fields)
    // Type assertion safe because we merged with DEFAULT_STACK which has all fields
    const researchResults = generateMockResearchResults(completeStack as Required<SimpleTechStack>)

    // Save research results to Convex
    await convexClient.mutation(api.conversations.saveResearchResults, {
      conversationId,
      results: researchResults,
      autoGenerated: true,
    })

    // Save validated/fixed selection once
    await convexClient.mutation(api.conversations.saveSelection, {
      conversationId,
      selection: {
        frontend: completeStack.frontend!,
        backend: completeStack.backend!,
        database: completeStack.database!,
        auth: completeStack.auth!,
        hosting: completeStack.hosting!,
      },
      autoSelected: true,
    })

    return NextResponse.json({
      success: true,
      techStack,
      validation,
    })
  } catch (error) {
    return handleAPIError(error, "generate default tech stack");
  }
});

async function getAISuggestedStack(extractedContext: ExtractedContext, answers: Question[] | null) {
  const response = await anthropic.messages.create({
    model: AI_MODELS.CLAUDE_SONNET,
    max_tokens: TOKEN_LIMITS.TECH_STACK,
    temperature: 0.3,
    messages: [{
      role: 'user',
      content: TECH_STACK_SUGGESTION_PROMPT(extractedContext, answers)
    }],
  })

  const firstBlock = response.content[0]
  if (!firstBlock || firstBlock.type !== 'text') {
    throw new Error('Unexpected response type from Claude')
  }
  const textContent = firstBlock

  return safeParseAIResponse<SimpleTechStack>(textContent.text) || getDefaultTechStack(extractedContext, answers)
}

function validateDefaultStack(stack: SimpleTechStack): ValidationResult {
  const errors: string[] = [];
  const warnings: string[] = [];

  // Normalize and validate required fields
  const fields: Array<keyof SimpleTechStack> = ['frontend', 'backend', 'database', 'auth', 'hosting'];

  fields.forEach(field => {
    const value = stack[field]?.trim();
    if (!value) {
      const fieldName = field.charAt(0).toUpperCase() + field.slice(1);
      errors.push(`${fieldName === 'Auth' ? 'Authentication solution' : fieldName + (field === 'hosting' ? ' platform' : ' framework')} is required`);
    } else {
      // Normalize: trim and assign back
      stack[field] = value;
    }
  });

  // Basic compatibility checks
  if (stack.frontend && stack.hosting) {
    // Warn if using React/Next.js but not deploying to Vercel
    if (
      (stack.frontend.toLowerCase().includes("next") ||
        stack.frontend.toLowerCase().includes("react")) &&
      !stack.hosting.toLowerCase().includes("vercel")
    ) {
      warnings.push(
        "Consider Vercel for Next.js/React apps for optimal DX"
      );
    }
  }

  // Warn about potential compatibility issues
  if (stack.backend && stack.database) {
    // Example: MongoDB works best with Node.js
    if (
      stack.database.toLowerCase().includes("mongo") &&
      !stack.backend.toLowerCase().includes("node")
    ) {
      warnings.push(
        "MongoDB is typically used with Node.js backends"
      );
    }
  }

  return {
    isValid: errors.length === 0,
    errors,
    warnings,
  };
}

async function fixStackErrors(
  stack: SimpleTechStack,
  _errors: string[]
): Promise<SimpleTechStack> {
  // Merge with defaults to fix missing fields
  return {
    ...DEFAULT_STACK,
    ...stack,
  };
}
