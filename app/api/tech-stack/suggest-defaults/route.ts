import { NextRequest, NextResponse } from 'next/server'
import Anthropic from '@anthropic-ai/sdk'
import { ConvexHttpClient } from 'convex/browser'
import { api } from '@/convex/_generated/api'
import { getDefaultTechStack, generateMockResearchResults } from '@/lib/techStack/defaults'

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY,
})

const convex = new ConvexHttpClient(process.env.NEXT_PUBLIC_CONVEX_URL!)

export async function POST(request: NextRequest) {
  try {
    const { conversationId, useAI = false } = await request.json()

    // Fetch conversation data
    const conversation = await convex.query(api.conversations.get, {
      conversationId,
    })

    if (!conversation) {
      return NextResponse.json(
        { error: 'Conversation not found' },
        { status: 404 }
      )
    }

    const extractedContext = conversation.extractedContext
    const clarifyingQuestions = conversation.clarifyingQuestions

    let techStack

    if (useAI && extractedContext) {
      // Use Claude for smarter suggestions
      techStack = await getAISuggestedStack(extractedContext, clarifyingQuestions)
    } else {
      // Use rule-based defaults
      techStack = getDefaultTechStack(extractedContext, clarifyingQuestions)
    }

    // Generate mock research results
    const researchResults = generateMockResearchResults(techStack)

    // Save to Convex
    await convex.mutation(api.conversations.saveResearchResults, {
      conversationId,
      results: researchResults,
      autoGenerated: true,
    })

    // Save selection
    await convex.mutation(api.conversations.saveSelection, {
      conversationId,
      selection: techStack,
      autoSelected: true,
    })

    // Validate the stack
    const validation = await validateDefaultStack(techStack)

    if (validation.errors.length > 0) {
      // If there are errors, try to fix them
      techStack = await fixStackErrors(techStack, validation.errors)

      // Re-save fixed selection
      await convex.mutation(api.conversations.saveSelection, {
        conversationId,
        selection: techStack,
        autoSelected: true,
      })
    }

    return NextResponse.json({
      success: true,
      techStack,
      validation,
    })
  } catch (error) {
    console.error('Default tech stack error:', error)
    return NextResponse.json(
      { error: 'Failed to generate defaults', details: (error as Error).message },
      { status: 500 }
    )
  }
}

async function getAISuggestedStack(extractedContext: any, answers: any) {
  const prompt = `
Suggest an optimal tech stack for this product:

PRODUCT CONTEXT:
${JSON.stringify(extractedContext, null, 2)}

ANSWERS:
${JSON.stringify(answers, null, 2)}

Based on this information, suggest:
1. Frontend framework/library
2. Backend framework/language
3. Database
4. Authentication solution
5. Hosting platform

Consider:
- Product type and scale
- Target audience
- Technical preferences mentioned
- Industry best practices
- Developer experience
- Cost-effectiveness

Return ONLY a JSON object:
{
  "frontend": "technology name",
  "backend": "technology name",
  "database": "technology name",
  "auth": "technology name",
  "hosting": "technology name"
}
`

  const response = await anthropic.messages.create({
    model: 'claude-sonnet-4-5-20250929',
    max_tokens: 1024,
    temperature: 0.3,
    messages: [{ role: 'user', content: prompt }],
  })

  const textContent = response.content.find((block) => block.type === 'text')
  if (!textContent || textContent.type !== 'text') {
    throw new Error('Unexpected response type from Claude')
  }

  return JSON.parse(textContent.text)
}

async function validateDefaultStack(_stack: any) {
  // Basic validation - could be enhanced
  return {
    isValid: true,
    errors: [],
    warnings: [],
  }
}

async function fixStackErrors(_stack: any, _errors: any[]) {
  // If there are compatibility errors, fall back to safest defaults
  return {
    frontend: 'Next.js',
    backend: 'Node.js with Express',
    database: 'PostgreSQL',
    auth: 'Clerk',
    hosting: 'Vercel',
  }
}
